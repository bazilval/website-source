<html>
<head>
  <meta name="layout" content="_layout/docs_features_l2caching.html"/>
  <#assign l2caching_overview="active">
</head>
<body>
  <h2 id="overview">Overview</h2>
  <p>
    The goal of the L2 cache is to gain very significant performance improvement by
    not having to hit the database to read some information.
  </p>
  <p>
    For example, instead of performing a "find by id" or "find by unique key" query we
    can get Ebean to effectively lookup the result in the L2 cache. If we are using <em>near caching</em>
    then this might often result in an in-memory lookup into a local Map and not even require a
    remote call so be very fast.
  </p>
  <p>
    It is called the "Level 2 cache" because the persistence context is often referred to as the "Level 1 cache".
  </p>
  <p>
    The "L2 cache" has 2 main caches – "Bean caches" and "Query caches".
  </p>

  <h3>Bean Caches</h3>
  <p>
    Bean caches hold entity beans and are keyed by their <em>Id</em> values and optionally also
    by their <em>natural key</em>. The bean cache can be used with:
  </p>
  <ul>
    <li>Find by id(s)</li>
    <li>Find by natural key(s)</li>
  </ul>

  <h3>Query Caches</h3>
  <p>
    Query caches hold the results of queries (Lists, Sets, Maps of entity beans and Count) and are keyed
    by a hash of the query and its bind values.
  </p>
  <p>
    The entries in a query cache are invalidated by ANY change to the underlying table –
    insert, update or delete. This means that the query cache is generally only useful on entities that are
    relatively infrequently modified (typically "lookup tables" such as countries, currencies, status codes
    etc).
  </p>
  <p>
    The query cache can be used with:
  </p>
  <ul>
    <li>Find list/set/map queries</li>
  </ul>

  <h2 id="read-consistency">Eventual consistency</h2>
  <p>
    Ebean L2 caching uses <em>eventual consistency</em>.
  </p>
  <p>
    This means it operates a bit like "replication lag". Data returned from the L2 cache can be (milliseconds) out
    of date. Changes will be made to the cache in a relatively short time (milliseconds) but there isn't the
    gauruntee of read consistency that our transactional database provides.
  </p>
  <p>
    With Ebean L2 caching there is no attempt to provide transactional read consistency.
    If part of an application needs transactional read consistency then we should <em>use the database</em> to do that.
  </p>

  <h2 id="invalidation">Invalidation</h2>
  <p>
    Ebean will automatically invalidate the cache when <a href="/docs/features/l2cache/invalidation#bean">beans are persisted</a>
    or <a href="/docs/features/l2cache/invalidation#table">update queries</a> are executed.
  </p>
  <p>
    In addition we can explicitly <a href="/docs/features/l2cache/invalidation#explicit">invalidate parts of the cache</a>
    programmatically.
  </p>


</body>
</html>
